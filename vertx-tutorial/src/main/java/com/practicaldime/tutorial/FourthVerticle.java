package com.practicaldime.tutorial;

import static com.practicaldime.tutorial.ActionHelper.created;
import static com.practicaldime.tutorial.ActionHelper.noContent;
import static com.practicaldime.tutorial.ActionHelper.ok;

import java.util.List;
import java.util.NoSuchElementException;
import java.util.stream.Collectors;

import com.practicaldime.tutorial.entity.Location;

import io.vertx.config.ConfigRetriever;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.CompositeFuture;
import io.vertx.core.Future;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.core.logging.Logger;
import io.vertx.core.logging.LoggerFactory;
import io.vertx.ext.jdbc.JDBCClient;
import io.vertx.ext.sql.SQLConnection;
import io.vertx.ext.sql.SQLOptions;
import io.vertx.ext.sql.UpdateResult;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.RoutingContext;
import io.vertx.ext.web.handler.BodyHandler;
import io.vertx.ext.web.handler.StaticHandler;

public class FourthVerticle extends AbstractVerticle {

	private final Logger logger = LoggerFactory.getLogger(FourthVerticle.class);
	private JDBCClient jdbc;
	
	public void start(Future<Void> fut) {
		
		//create router
		Router router = Router.router(vertx);
		
		//bind handlers to router
		router.route("/").handler(rc -> {
			rc.response()
			.putHeader("Content-Type", "text/html")
			.end("<h1>Hello Http Vertx!</h1>");
		});
		
		//configure static resources
		router.route("/assets/*").handler(StaticHandler.create("assets"));
		
		// add /api/* handlers
		router.get("/api/location").handler(this::getAll);
		router.route("/api/location*").handler(BodyHandler.create());
		router.post("/api/location").handler(this::addOne);
		router.get("/api/location/:id").handler(this::getOne);
		router.delete("/api/location/:id").handler(this::deleteOne);
		router.put("/api/location/:id").handler(this::updateOne);
		
		//fire up server and use router
		ConfigRetriever retriever = ConfigRetriever.create(vertx);
		ConfigRetriever.getConfigAsFuture(retriever)
			.compose(config -> {
				//create jdbc client
				jdbc = JDBCClient.createShared(vertx, config, "Locations List");
				return connect()
					.compose(connection -> {
						Future<Void> future = Future.future();
						createTableIfNeedBe(connection)
						.compose(this::createInitialDataIfNone)
						.setHandler(x -> {
							connection.close();
							future.handle(x.mapEmpty());
						});
						return future;
					})
					.compose(v -> createHttpServer(config, router));
				}).setHandler(fut);
		
	}

	private Future<SQLConnection> connect() {
		Future<SQLConnection> future = Future.future();
		jdbc.getConnection(ar -> 
			future.handle(ar.map(connection -> 
				connection.setOptions(new SQLOptions().setAutoGeneratedKeys(true))
			)));
		return future;
	}
	
	private Future<SQLConnection> createTableIfNeedBe(SQLConnection connection){
		Future<SQLConnection> future = Future.future();
		vertx.fileSystem().readFile("sql/tables.sql", ar -> {
			if(ar.failed()) {
				future.fail(ar.cause());
			}
			else {
				connection.execute(ar.result().toString(),
					ar2 -> future.handle(ar2.map(connection)));
			}
		});
		return future;
	}
	
	private Future<SQLConnection> createInitialDataIfNone(SQLConnection connection){
		Future<SQLConnection> future = Future.future();
		connection.query("SELECT * FROM tbl_location", select -> {
			if(select.failed()) {
				future.fail(select.cause());
			}
			else {
				if(select.result().getResults().isEmpty()) {
					Location chicago = new Location(null, "chicago", "IL", "60455", "US");
					Future<Location> chicagoIn = insert(connection, chicago, false);
					Location madison = new Location(null, "madison", "WI", "53718", "US");
					Future<Location> madisonIn = insert(connection, madison, false);
					Location seattle = new Location(null, "seattle", "WA", "98030", "US");
					Future<Location> seattleIn = insert(connection, seattle, false);
					Location houston = new Location(null, "houston", "TX", "75499", "US");
					Future<Location> houstonIn = insert(connection, houston, false);
					Location nairobi = new Location(null, "nairobi", "KE", "00100", "KE");
					Future<Location> nairobiIn = insert(connection, nairobi, false);
					
					//compose all futures
					CompositeFuture.all(chicagoIn, madisonIn, seattleIn, houstonIn, nairobiIn)
					.setHandler(r-> future.handle(r.map(connection)));
				}
				else {
					future.complete(connection);
				}
			}
		});
		return future;
	}
	
	private Future<Location> insert(SQLConnection connection, Location location, boolean closeConnection){
		Future<Location> future = Future.future();
		String sql = "INSERT INTO tbl_location (loc_city, loc_state, loc_zip, country_code) VALUES (?, ?, ?, ?)";
		logger.info("request to create a new location for " + location.getCity());
		connection.updateWithParams(sql, new JsonArray()
				.add(location.getCity())
				.add(location.getState())
				.add(location.getZip())
				.add(location.getCountry()), ar -> {
					if(closeConnection) {
						connection.close();
					}
					future.handle(ar.map(ur -> 
						new Location(ur.getKeys().getLong(0), location.getCity(), location.getState(), location.getZip(), location.getCountry())
					));
				});
		return future;
	}
	
	private Future<Void> createHttpServer(JsonObject config, Router router){
		Future<Void> future = Future.future();
		vertx.createHttpServer()
		.requestHandler(router)
		.listen(
			config.getInteger("http.port", 8080), 
			res -> future.handle(res.mapEmpty()));
		return future;
	}	
	
	private Future<List<Location>> query(SQLConnection connection){
		Future<List<Location>> future = Future.future();
		logger.info("request to fetch all available locations");
		connection.query("SELECT * FROM tbl_location", result -> {
			connection.close();
			future.handle(
				result.map(rs -> rs.getRows().stream()
						.map(Location::new)
						.collect(Collectors.toList()))
			);
		});
		return future;
	}
	
	private Future<Location> queryOne(SQLConnection connection, String id){
		Future<Location> future = Future.future();
		String sql = "SELECT * FROM tbl_location WHERE location_id = ?";
		logger.info("request to retrieve location with id " + id);
		connection.queryWithParams(sql, new JsonArray().add(Long.valueOf(id)), 
				result -> {
					connection.close();
					future.handle(
					result.map(rs -> {
						List<JsonObject> rows = rs.getRows();
						if(rows.size() > 0) {
							throw new NoSuchElementException("No location with id " + id);
						}
						else {
							JsonObject row = rows.get(0);
							return new Location(row);
						}
					})
				);
			});
		return future;
	}
	
	public Future<Void> update(SQLConnection connection, String id, Location loc){
		Future<Void> future = Future.future();
		String sql = "UPDATE tbl_location SET loc_city = ?, loc_state = ?, loc_state = ?, country_code = ? where location_id = ?";
		logger.info("request to update location with id " + id);
		connection.updateWithParams(sql, new JsonArray()
				.add(loc.getCity())
				.add(loc.getState())
				.add(loc.getState())
				.add(loc.getCountry())
				.add(Long.valueOf(id)), result -> {
					connection.close();
					if(result.failed()) {
						future.fail(result.cause());
					}
					else {
						UpdateResult ur = result.result();
						if(ur.getUpdated() == 0) {
							future.fail(new NoSuchElementException("No location was found with id " + id));
						}
						else {
							future.complete();
						}
					}
				});
		return future;
	}
	
	private Future<Void> delete(SQLConnection connection, String id){
		Future<Void> future = Future.future();
		String sql = "DELETE FROM tbl_location WHERE location_id = ?";
		logger.info("request to remove location with id " + id);
		connection.updateWithParams(sql, new JsonArray().add(Long.valueOf(id)), result -> {
			connection.close();
			if(result.failed()) {
				future.fail(result.cause());
			}
			else {
				if(result.result().getUpdated() == 0) {
					future.fail(new NoSuchElementException("No location with id " + id));
				}
				else {
					future.complete();
				}
			}
		});
		return future;
	}
	
	public void getAll(RoutingContext ctx) {
		connect().compose(this::query).setHandler(ok(ctx));
	}
	
	public void addOne(RoutingContext ctx) {
		Location loc = ctx.getBodyAsJson().mapTo(Location.class);
		connect()
		.compose(connection -> insert(connection, loc, true))
		.setHandler(created(ctx));
	}
	
	public void getOne(RoutingContext ctx) {
		String id = ctx.pathParam("id");
		connect()
		.compose(connection -> queryOne(connection, id))
		.setHandler(ok(ctx));
	}
	
	public void deleteOne(RoutingContext ctx) {
		String id = ctx.pathParam("id");
		connect()
		.compose(connection -> delete(connection, id))
		.setHandler(noContent(ctx));
	}
	
	public void updateOne(RoutingContext ctx) {
		String id = ctx.pathParam("id");
        Location loc = ctx.getBodyAsJson().mapTo(Location.class);
        connect()
        .compose(connection -> update(connection, id, loc))
        .setHandler(noContent(ctx));
	}
}
