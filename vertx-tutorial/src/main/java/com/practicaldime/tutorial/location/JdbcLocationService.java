package com.practicaldime.tutorial.location;

import java.util.List;
import java.util.NoSuchElementException;
import java.util.stream.Collectors;

import com.practicaldime.tutorial.entity.Location;

import io.vertx.core.CompositeFuture;
import io.vertx.core.Future;
import io.vertx.core.Vertx;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.core.logging.Logger;
import io.vertx.core.logging.LoggerFactory;
import io.vertx.ext.jdbc.JDBCClient;
import io.vertx.ext.sql.SQLConnection;
import io.vertx.ext.sql.SQLOptions;
import io.vertx.ext.sql.UpdateResult;

public class JdbcLocationService implements LocationService {

	private final Logger logger = LoggerFactory.getLogger(JdbcLocationService.class);
	private final Vertx vertx;
	private final JDBCClient jdbc;
	
	public JdbcLocationService(JsonObject config) {
		this(Vertx.vertx(), config);
	}

	public JdbcLocationService(Vertx vertx, JsonObject config) {
		super();
		this.vertx = vertx;
		this.jdbc = JDBCClient.createShared(vertx, config);
	}
	
	private Future<SQLConnection> connect() {
		Future<SQLConnection> future = Future.future();
		jdbc.getConnection(ar -> 
			future.handle(ar.map(connection -> 
				connection.setOptions(new SQLOptions().setAutoGeneratedKeys(true))
			)));
		return future;
	}
	
	private Future<SQLConnection> createTableIfNeedBe(SQLConnection connection){
		Future<SQLConnection> future = Future.future();
		vertx.fileSystem().readFile("sql/tables.sql", ar -> {
			if(ar.failed()) {
				future.fail(ar.cause());
			}
			else {
				connection.execute(ar.result().toString(),
					ar2 -> future.handle(ar2.map(connection)));
			}
		});
		return future;
	}
	
	private Future<SQLConnection> createInitialDataIfNone(SQLConnection connection){
		Future<SQLConnection> future = Future.future();
		connection.query("SELECT * FROM tbl_location", select -> {
			if(select.failed()) {
				future.fail(select.cause());
			}
			else {
				if(select.result().getResults().isEmpty()) {
					Location chicago = new Location(null, "chicago", "IL", "60455", "US");
					Future<Location> chicagoIn = insert(chicago);
					Location madison = new Location(null, "madison", "WI", "53718", "US");
					Future<Location> madisonIn = insert(madison);
					Location seattle = new Location(null, "seattle", "WA", "98030", "US");
					Future<Location> seattleIn = insert(seattle);
					Location houston = new Location(null, "houston", "TX", "75499", "US");
					Future<Location> houstonIn = insert(houston);
					Location nairobi = new Location(null, "nairobi", "KE", "00100", "KE");
					Future<Location> nairobiIn = insert(nairobi);
					
					//compose all futures
					CompositeFuture.all(chicagoIn, madisonIn, seattleIn, houstonIn, nairobiIn)
					.setHandler(r-> future.handle(r.map(connection)));
				}
				else {
					future.complete(connection);
				}
			}
		});
		return future;
	}

	@Override
	public Future<Void> initData() {
		return connect()
		.compose(connection -> {
			Future<Void> future = Future.future();
			createTableIfNeedBe(connection)
			.compose(this::createInitialDataIfNone)
			.setHandler(x -> {
				connection.close();
				future.handle(x.mapEmpty());
			});
			return future;
		});
	}

	@Override
	public Future<Location> insert(Location location) {
		Future<Location> future = Future.future();
		String sql = "INSERT INTO tbl_location (loc_city, loc_state, loc_zip, country_code) VALUES (?, ?, ?, ?)";
		logger.info("request to create a new location for " + location.getCity());
		connect().setHandler(con -> {
			if(con.succeeded()) {
				con.result().updateWithParams(sql, new JsonArray()
					.add(location.getCity())
					.add(location.getState())
					.add(location.getZip())
					.add(location.getCountry()), ar -> {	
						future.handle(ar.map(ur -> 
							new Location(ur.getKeys().getLong(0), location.getCity(), location.getState(), location.getZip(), location.getCountry())
						));
				});
				//close connection
				con.result().close();
			}
			else{
				future.fail(con.cause());
			}
		});
		return future;
	}

	@Override
	public Future<List<Location>> getAll() {
		Future<List<Location>> future = Future.future();
		logger.info("request to fetch all available locations");
		connect().setHandler(con -> {
			if(con.succeeded()) {
				con.result().query("SELECT * FROM tbl_location", result -> {
					con.result().close();
					future.handle(
						result.map(rs -> rs.getRows().stream()
								.map(Location::new)
								.collect(Collectors.toList()))
					);
				});
			}
			else{
				future.fail(con.cause());
			}
		});
		return future;
	}

	@Override
	public Future<Location> getCertain(String id) {
		Future<Location> future = Future.future();
		String sql = "SELECT * FROM tbl_location WHERE location_id = ?";
		logger.info("request to retrieve location with id " + id);
		connect().setHandler(con -> {
			if(con.succeeded()) {
				con.result().queryWithParams(sql, new JsonArray().add(Long.valueOf(id)), 
				result -> {
					con.result().close();
					future.handle(
					result.map(rs -> {
						List<JsonObject> rows = rs.getRows();
						if(rows.size() > 0) {
							throw new NoSuchElementException("No location with id " + id);
						}
						else {
							JsonObject row = rows.get(0);
							return new Location(row);
						}
					})
				);
			});
			}
			else {
				future.fail(con.cause());
			}
		});
				
		return future;
	}

	@Override
	public Future<Void> update(String id, Location loc) {
		Future<Void> future = Future.future();
		String sql = "UPDATE tbl_location SET loc_city = ?, loc_state = ?, loc_state = ?, country_code = ? where location_id = ?";
		logger.info("request to update location with id " + id);
		connect().setHandler(con -> {
			if(con.succeeded()) {
				con.result().updateWithParams(sql, new JsonArray()
				.add(loc.getCity())
				.add(loc.getState())
				.add(loc.getState())
				.add(loc.getCountry())
				.add(Long.valueOf(id)), result -> {
					con.result().close();
					if(result.failed()) {
						future.fail(result.cause());
					}
					else {
						UpdateResult ur = result.result();
						if(ur.getUpdated() == 0) {
							future.fail(new NoSuchElementException("No location was found with id " + id));
						}
						else {
							future.complete();
						}
					}
				});
			}
			else {
				future.fail(con.cause());
			}
		});
		return future;
	}

	@Override
	public Future<Void> delete(String id) {
		Future<Void> future = Future.future();
		String sql = "DELETE FROM tbl_location WHERE location_id = ?";
		logger.info("request to remove location with id " + id);
		connect().setHandler(con -> {
			if(con.succeeded()) {
				con.result().updateWithParams(sql, new JsonArray().add(Long.valueOf(id)), result -> {
					con.result().close();
					if(result.failed()) {
						future.fail(result.cause());
					}
					else {
						if(result.result().getUpdated() == 0) {
							future.fail(new NoSuchElementException("No location with id " + id));
						}
						else {
							future.complete();
						}
					}
				});
			}
			else {
				future.fail(con.cause());
			}
		});
		return future;
	}

	@Override
	public Future<Boolean> deleteAll() {
		Future<Boolean> future = Future.future();
		String sql = "TRUNCATE TABLE tbl_location ?";
		logger.info("request to remove all locations");
		connect().setHandler(con -> {
			if(con.succeeded()) {
				con.result().update(sql, result -> {
					con.result().close();
					if(result.failed()) {
						future.fail(result.cause());
					}
					else {
						future.complete(true);
					}
				});
			}
			else {
				future.fail(con.cause());
			}
		});
		return future;
	}
}
